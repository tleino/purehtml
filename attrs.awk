BEGIN {
	for (i = 0; i < 256; i++)
		ord[sprintf("%c",i)] = i;
	hashsz = 1024;
}
/^[a-zA-Z_]/ {
	flags = "";
	jump = 0;
	for (i = 1; i <= length($2); i++) {
		if (i != 1)
			flags = flags " | ";
		if (substr($2,i,1) ~ /g/)
			flags = flags "ATTR_FLAG_GLOBAL";
		if (substr($2,i,1) ~ /e/)
			flags = flags "ATTR_FLAG_EVENT";
	}
	if (length($2) == 0)
		flags = "0";

	addr = 0;
	key = $1;
	key = key "0";
	prime = 104729;
	modulo = 1048576;
	split($1, chars, "");
	for (i = 1; i <= length($1); i++) {
		c = ord[chars[i]];
		addr += c;
		addr *= prime;
		addr %= modulo;
	}
	addr %= hashsz;
	while (attr_arr[addr] != "") {
		addr++;
		addr %= hashsz;
		jump++;
	}
	if (flags == "")
		flags = 0;
	if (jump > 0)
		attr_arr[addr] = sprintf("\t{ \"%s\", %s } /* jump %d */,", $1, flags, jump);
	else
		attr_arr[addr] = sprintf("\t{ \"%s\", %s },", $1, flags);
	attr_names[addr] = toupper($1);
}
END {
	printf("/* generated by attrs.awk */\n");
	if (mode == "c") {
		printf("static const struct attr_map attr_map[] = {\n");
		for (i = 0; i < hashsz; i++) {
			if (attr_arr[i] == "")
				printf("\t{ NULL, 0 }, /* %d */\n", i);
			else
				printf("%s /* %d */\n", attr_arr[i], i);
		}
		printf("};\n");
	} else {
		printf("enum attrid {\n");
		for (i = 0; i < hashsz; i++) {
			if (attr_names[i] != "")
				printf("\tATTR_%s=%d,\n", attr_names[i], i);
		}
		printf("};\n");
	}
}
